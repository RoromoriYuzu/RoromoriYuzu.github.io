import{_ as a,c as i,o as n,ag as e}from"./chunks/framework.BgId8OS5.js";const l="/matlab.assets/image-20230411194430297.png",E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/Tool/Matlab.md","filePath":"posts/Tool/Matlab.md","lastUpdated":null}'),p={name:"posts/Tool/Matlab.md"};function t(d,s,h,r,c,k){return n(),i("div",null,s[0]||(s[0]=[e(`<h2 id="cvpartition-函数" tabindex="-1">cvpartition 函数 <a class="header-anchor" href="#cvpartition-函数" aria-label="Permalink to &quot;cvpartition 函数&quot;">​</a></h2><p><code>cvpartition</code> 函数是 MATLAB 中用于生成交叉验证数据集索引的函数。交叉验证是一种常用的机器学习方法，用于评估和选择模型，避免过拟合。</p><p><code>cvpartition</code> 函数的基本语法如下：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c = cvpartition(group,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;KFold&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,k)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其中，<code>group</code> 是一个向量，表示数据集中每个样本所属的类别或分组；<code>&#39;KFold&#39;</code> 表示使用 K 折交叉验证方法；<code>k</code> 表示将数据集分成 K 份。<code>c</code> 是一个 <code>cvpartition</code> 类型的对象，保存了交叉验证数据集的索引，可以用于训练和测试模型。</p><p>下面是 <code>cvpartition</code> 函数的一些常用参数和用法：</p><ul><li><p><code>&#39;HoldOut&#39;</code> 方法：将数据集分成训练集和测试集两部分，可以使用 <code>&#39;HoldOut&#39;</code> 方法生成索引。语法如下：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c = cvpartition(group,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;HoldOut&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,p)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其中，<code>p</code> 表示将数据集分成的测试集的比例，通常取值为 0.5 ~ 0.9。</p></li><li><p><code>&#39;LeaveOut&#39;</code> 方法：将每个样本单独作为测试集，其他样本作为训练集，可以使用 <code>&#39;LeaveOut&#39;</code> 方法生成索引。语法如下：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c = cvpartition(group,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;LeaveOut&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><code>&#39;StratifiedKFold&#39;</code> 方法：在 K 折交叉验证中，保持每个类别的样本比例相同，可以使用 <code>&#39;StratifiedKFold&#39;</code> 方法生成索引。语法如下：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c = cvpartition(group,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;StratifiedKFold&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,k)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><code>&#39;StratifiedHoldOut&#39;</code> 方法：将数据集分成训练集和测试集两部分，并根据每个类别的样本比例保持训练集和测试集中每个类别的样本比例相同，可以使用 <code>&#39;StratifiedHoldOut&#39;</code> 方法生成索引。语法如下：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c = cvpartition(group,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;StratifiedHoldOut&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,p)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其中，<code>p</code> 表示将数据集分成的训练集的比例。</p></li><li><p><code>&#39;StratifiedLeaveOut&#39;</code> 方法：将每个样本单独作为测试集，其他样本作为训练集，并根据每个类别的样本比例保持训练集和测试集中每个类别的样本比例相同，可以使用 <code>&#39;StratifiedLeaveOut&#39;</code> 方法生成索引。语法如下：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c = cvpartition(group,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;StratifiedLeaveOut&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="返回值" tabindex="-1">返回值 <a class="header-anchor" href="#返回值" aria-label="Permalink to &quot;返回值&quot;">​</a></h3></li></ul><p>使用 <code>cvpartition</code> 函数的 <code>&#39;HoldOut&#39;</code> 方法生成训练集和测试集的索引时，返回一个 <code>cvpartition</code> 类型的对象，该对象包含两个属性：</p><ul><li><code>trainingIndices</code>：训练集的索引，是一个逻辑向量，其中训练集对应的位置为 <code>true</code>，测试集对应的位置为 <code>false</code>。对应数组为 1 或 0 。</li><li><code>testIndices</code>：测试集的索引，是一个逻辑向量，其中测试集对应的位置为 <code>true</code>，训练集对应的位置为 <code>false</code>。</li></ul><p>例如，如果使用以下语句将数据集 <code>data</code> 分成训练集和测试集：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c = cvpartition(n,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;HoldOut&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,p);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">trainData = data(c.trainingIndices,:);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">testData = data(c.testIndices,:);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>则 <code>c.trainingIndices</code> 和 <code>c.testIndices</code> 分别是大小为 <code>n</code> 的逻辑向量，其中 <code>c.trainingIndices(i)</code> 和 <code>c.testIndices(i)</code> 分别表示第 <code>i</code> 个样本是否属于训练集或测试集。</p><p>需要注意的是，使用 <code>&#39;HoldOut&#39;</code> 方法生成训练集和测试集的索引时，需要根据具体的应用场景选择合适的训练集比例 <code>p</code>，通常取值为 0.5 ~ 0.9。选择过小的训练集比例可能导致模型过拟合，而选择过大的训练集比例可能导致模型欠拟合。</p><h2 id="加载鸢尾花数据集" tabindex="-1">加载鸢尾花数据集 <a class="header-anchor" href="#加载鸢尾花数据集" aria-label="Permalink to &quot;加载鸢尾花数据集&quot;">​</a></h2><p>首先，加载鸢尾花数据集：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fisheriris</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接着，将数据集和类别分开：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> codeX = meas;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Y = species;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后，使用<code>cvpartition</code>函数将数据集划分为训练集和测试集。在这个例子中，我们将70%的数据用于训练，30%的数据用于测试：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> codecv = cvpartition(Y,&#39;HoldOut&#39;,0.3);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">idx = cv.test;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>现在，我们可以将训练集和测试集分开：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> codeXtrain = X(~idx,:);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Ytrain = Y(~idx,:);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Xtest = X(idx,:);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Ytest = Y(idx,:);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="逗号分隔符" tabindex="-1">逗号分隔符 <a class="header-anchor" href="#逗号分隔符" aria-label="Permalink to &quot;逗号分隔符&quot;">​</a></h2><p><img src="`+l+`" alt="image-20230411194430297" loading="lazy"></p><h2 id="knn分类器" tabindex="-1">KNN分类器 <a class="header-anchor" href="#knn分类器" aria-label="Permalink to &quot;KNN分类器&quot;">​</a></h2><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">clear</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fisheriris</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X = meas;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Y = species;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cv = cvpartition(Y,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;HoldOut&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">idx = cv.test;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Xtrain = X(~idx,:);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Ytrain = Y(~idx,:);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Xtest = X(idx,:);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Ytest = Y(idx,:);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mdl = fitcknn(Xtrain,Ytrain,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;NumNeighbors&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Ypredict = predict(mdl,Xtest);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">accuracy = sum(strcmp(Ytest,Ypredict))/numel(Ytest);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">disp([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;分类准确率&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,accuracy])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这段代码使用了鸢尾花数据集（<code>fisheriris</code>），将数据集划分为训练集和测试集，并训练了一个<code>k-NN</code>分类器。接下来对测试集进行分类并计算分类的准确率。</p><p>代码中 <code>cvpartition</code> 函数使用了“Holdout”方法将数据集分为训练集和测试集。其中，<code>Holdout</code> 的参数 <code>0.3</code> 表示将数据集划分为训练集和测试集的比例为 $7:3$，即测试集占总数据集的 $30%$。函数返回一个 <code>cv</code> 对象，其中 <code>test</code> 属性包含了测试集的索引。</p><p>接着，通过索引 <code>idx</code> 将数据集划分为训练集和测试集。训练集包含了 <code>~idx</code> 所表示的索引，测试集包含了 <code>idx</code> 所表示的索引。</p><p>然后，使用 <code>fitcknn</code> 函数训练了一个 <code>k-NN</code> 分类器。<code>NumNeighbors</code> 参数指定了 <code>k</code> 的值为 5。函数返回一个分类器模型 <code>mdl</code>。</p><p>之后，通过 <code>predict</code> 函数对测试集进行分类，得到了分类结果 <code>Ypredict</code>。通过 <code>strcmp</code> 函数比较测试集真实标签 <code>Ytest</code> 和预测标签 <code>Ypredict</code> 的值是否相等，得到分类的准确率。最后使用 <code>disp</code> 函数输出准确率的值。</p><h2 id="k-means-聚类器" tabindex="-1">k-means 聚类器 <a class="header-anchor" href="#k-means-聚类器" aria-label="Permalink to &quot;k-means 聚类器&quot;">​</a></h2><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">clear</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">% 加载鸢尾花数据集</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fisheriris;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">% 提取特征矩阵</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X = meas;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">% 将特征矩阵标准化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X = zscore(X);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">% 设置聚类数目和迭代次数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">k = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">maxIter = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">% 使用 K-means 算法进行聚类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[idx, C] = kmeans(X, k, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MaxIter&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, maxIter);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">% 聚类结果为 idx 聚类中心为 C</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">% 绘制聚类结果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gscatter(X(:,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), X(:,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), idx);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hold</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> on;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">plot(C(:,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), C(:,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;kx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MarkerSize&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;LineWidth&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">legend(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Cluster 1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Cluster 2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Cluster 3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Centroids&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">title(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;K-means Clustering of Iris Data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xlabel(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Sepal Length (cm)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ylabel(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Sepal Width (cm)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>首先，通过 <code>load fisheriris</code> 命令加载鸢尾花数据集。然后，将特征矩阵 <code>meas</code> 提取出来并进行标准化处理，即使用 <code>zscore</code> 命令将每个特征的均值归零、方差归一。这一步是为了使得每个特征对聚类结果的贡献相同。</p><p>接下来，通过 <code>k = 3</code> 和 <code>maxIter = 100</code> 命令设置聚类数目和最大迭代次数。在本例中，我们设置聚类数目为 3，即将数据集分为 3 类。同时，我们也设置了最大迭代次数为 100，以确保算法能够在可接受的时间内收敛。</p><p>然后，使用 <code>kmeans</code> 命令对标准化后的特征矩阵 <code>X</code> 进行聚类分析，并返回聚类索引 <code>idx</code> 和聚类中心 <code>C</code>。其中，聚类索引 <code>idx</code> 是一个列向量，包含了每个样本所属的聚类编号；聚类中心 <code>C</code> 是一个矩阵，其中每行对应一个聚类中心，列数等于特征数。</p><p>最后，使用 <code>gscatter</code> 命令将聚类结果绘制在二维平面上。<code>gscatter</code> 命令需要三个输入参数：X、Y 和 G，其中 X 和 Y 是两个列向量，分别表示每个样本在二维平面上的横纵坐标；G 是一个列向量，表示每个样本所属的聚类编号。<code>hold on</code> 命令是为了使得后面的 <code>plot</code> 命令能够将聚类中心绘制在同一幅图中。最后，通过 <code>legend</code>、<code>title</code>、<code>xlabel</code> 和 <code>ylabel</code> 命令设置图例、标题、横纵坐标轴的标签。</p>`,37)]))}const b=a(p,[["render",t]]);export{E as __pageData,b as default};
