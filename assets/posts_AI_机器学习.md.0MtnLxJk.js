import{_ as i,c as a,o as n,ag as p}from"./chunks/framework.BgId8OS5.js";const l="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/image-20230419111932753.png",c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/AI/机器学习.md","filePath":"posts/AI/机器学习.md","lastUpdated":null}'),h={name:"posts/AI/机器学习.md"};function e(t,s,k,r,d,E){return n(),a("div",null,s[0]||(s[0]=[p(`<h2 id="e" tabindex="-1">E <a class="header-anchor" href="#e" aria-label="Permalink to &quot;E&quot;">​</a></h2><p>e 与复利息息相关。复利是指在一定时间内，本金每经过一个确定的时间间隔所产生的利息，而复利计算中的自然常数 e 的出现与复利息息相关。</p><p>假设一笔本金 P ，以年利率 r 进行复利，每年复利次数为 n 次，则在一年后，本金 P 的总收益为：</p><p>P * (1 + r/n)^n</p><p>当 n 趋近于无穷大时，上式的极限值就是 e^(r)P，其中 e 是自然常数。因此，e 可以用来表示复利的极限情况，即当复利次数趋近于无穷大时，本金的增长速度会趋近于 e^(r) 倍。</p><h2 id="简单的线性回归" tabindex="-1">简单的线性回归 <a class="header-anchor" href="#简单的线性回归" aria-label="Permalink to &quot;简单的线性回归&quot;">​</a></h2><p>要构建一个通过身高预测体重的线性回归模型，你需要做以下步骤：</p><ol><li>收集数据集并进行清理，将身高和体重之间的对应关系记录下来，一般说，数据集可以从公共数据仓库中获取，例如UCI Machine Learning Repository。</li><li>将数据集分成训练集和测试集。一般来说，我们将数据集的 70% 分配给训练集，将剩下的 30% 分配给测试集。</li><li>导入相关的 Python 库，例如 NumPy、Pandas 和 Matplotlib。</li><li>为模型选择最优的算法，例如梯度下降法或正规方程法。</li><li>初始化模型参数并根据算法进行训练。</li><li>使用测试集测试模型预测的精确度，例如使用平均绝对误差（Mean Absolute Error）或平均平方误差的（Mean Squared Error）来度量。</li></ol><p>下面是一个用 Python 构建简单线性回归模型的例子：</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numpy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pandas </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pd</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sklearn.linear_model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinearRegression</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 从文件中读取数据集</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pd.read_csv(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;heights_weights.csv&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 将数据集分为训练集和测试集</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">train_data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.sample(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">frac</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">random_state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">test_data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.drop(train_data.index)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 初始化模型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg_model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinearRegression()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 训练模型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg_model.fit(train_data[[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Height&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]], train_data[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Weight&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 在测试集上进行预测</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">predictions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reg_model.predict(test_data[[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Height&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 计算预测精确度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.mean((predictions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_data[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Weight&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mae </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.mean(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">abs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(predictions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_data[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Weight&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rmse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.sqrt(mse)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Mean Squared Error:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mse)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Mean Absolute Error:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mae)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Root Mean Squared Error:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rmse)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>在上面的代码中，使用了 Pandas 从 CSV 文件中加载了一个数据集，并对训练集和测试集进行了分割。我们使用了 Scikit-learn 的线性回归模型，将身高作为自变量，体重作为因变量进行建模。我们使用训练集对模型进行了训练，并使用测试集对模型进行了测试，并计算了平均绝对误差、平均平方误差和平均平方根误差等指标来评估模型预测的精度。</p><h3 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h3><p>这两个数组中的数据似乎是身高和体重之间的关系数据。可以使用 NumPy 库提供的数组运算功能来进行简单线性回归分析，从而估计身高和体重之间的线性关系。</p><p>以下是一个简单的示例代码，使用 <code>scikit-learn</code> 库的线性回归模型来实现：</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numpy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sklearn.linear_model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinearRegression</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TrainDataHeight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.86</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.96</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.63</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.71</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.85</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TrainDataWeight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">48</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">51</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">59</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">75</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 构建线性回归模型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinearRegression()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model.fit(TrainDataHeight.reshape(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), TrainDataWeight)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 打印模型参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Intercept: &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model.intercept_)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Coefficient: &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model.coef_)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 预测新数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">height_new </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.6</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">weight_new </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> model.predict([[height_new]])</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Predicted weight for height </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.format(height_new), weight_new[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>上述代码中，首先定义了 <code>TrainDataHeight</code> 和 <code>TrainDataWeight</code> 两个数组，分别表示身高和体重的数据。然后，使用 <code>LinearRegression</code> 类来构建线性回归模型，并使用 <code>fit</code> 方法来拟合数据。</p><p>接着，使用 <code>intercept_</code> 和 <code>coef_</code> 属性分别获取模型的截距和系数。最后，使用 <code>predict</code> 方法来预测新的数据。</p><p>请注意，在实际应用中，需要对数据进行更多的处理和分析，以确保模型的准确性和可靠性。同时，也需要对模型进行评估和优化，以进一步提高模型的性能和泛化能力。</p><h3 id="reshape-有什么作用" tabindex="-1">.reshape 有什么作用 <a class="header-anchor" href="#reshape-有什么作用" aria-label="Permalink to &quot;.reshape 有什么作用&quot;">​</a></h3><p><code>.reshape()</code> 是 NumPy 数组对象的一个方法，用于调整数组的形状（维度）。它可以改变数组的维数，也可以改变各维度的大小，但是数组的总元素数量不能改变。</p><p><code>.reshape()</code> 方法可以传递一个元组（tuple）作为参数，其中每个元素表示新维度的大小。如果元组中的元素个数与原数组的维度数不同，则需要在元组中相应位置上传递 <code>-1</code>，表示该维度的大小由系统自动推断。</p><p>在机器学习中，常常需要将输入数据调整成指定的维度，以输入到模型中进行训练或预测。例如，在上一个问题的示例代码中，使用 <code>.reshape(-1, 1)</code> 将 <code>TrainDataHeight</code> 数组从一维转换为二维，以满足 <code>LinearRegression()</code> 类的输入要求。</p><p>以下是一个简单的示例代码，用于演示 <code>.reshape()</code> 方法的用法：</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numpy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 创建一个 2x3 的数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]])</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 将数组转换为 3x2 的形状</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr_reshaped </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.reshape((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr_reshaped)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 将数组转换为 1x6 的形状（使用 -1 自动推断维度大小）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr_reshaped </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.reshape((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr_reshaped)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>上述代码中，首先创建了一个 2x3 的数组 <code>arr</code>，然后使用 <code>.reshape()</code> 方法将其转换为 3x2 和 1x6 的形状，并输出结果。</p><p>请注意，在使用 <code>.reshape()</code> 方法时，需要确保新维度的大小与原数组的总元素数量相同，否则会引发 <code>ValueError</code> 异常。此外，还需要注意数组的存储顺序（行优先或列优先）可能会影响 <code>.reshape()</code> 方法的结果。</p><h3 id="为什么traindataheight-需要reshape-而traindataweight不用" tabindex="-1">为什么TrainDataHeight 需要Reshape,而TrainDataWeight不用 <a class="header-anchor" href="#为什么traindataheight-需要reshape-而traindataweight不用" aria-label="Permalink to &quot;为什么TrainDataHeight 需要Reshape,而TrainDataWeight不用&quot;">​</a></h3><p>在机器学习中，通常要求输入数据的格式为二维数组，其中一维表示样本数量，另一维表示每个样本的特征数量。在本问题中，<code>TrainDataHeight</code> 和 <code>TrainDataWeight</code> 分别表示身高和体重的数据，需要将它们转换为二维数组的形式，以便于输入到模型中进行训练或预测。</p><p>但是，<code>TrainDataHeight</code> 和 <code>TrainDataWeight</code> 的含义不同，因此需要采用不同的转换方式。</p><p>对于 <code>TrainDataWeight</code> 数组，它只包含一个特征（体重），因此可以看做是一个一维数组，可以直接作为模型的输入。在模型训练时，<code>LinearRegression()</code> 类会自动将其转换为二维数组的形式，其中一维表示样本数量，另一维表示特征数量（这里为 1）。</p><p>对于 <code>TrainDataHeight</code> 数组，它也只包含一个特征（身高），但是它是一个一维数组，不能直接作为模型的输入。因此，需要使用 <code>.reshape()</code> 方法将其转换为二维数组的形式，其中一维表示样本数量，另一维表示特征数量（这里为 1）。</p><p>因此，<code>TrainDataHeight</code> 需要使用 <code>.reshape()</code> 方法转换为二维数组的形式，而 <code>TrainDataWeight</code> 不需要进行转换，可以直接作为模型的输入。</p><h2 id="中文画图乱码" tabindex="-1">中文画图乱码 <a class="header-anchor" href="#中文画图乱码" aria-label="Permalink to &quot;中文画图乱码&quot;">​</a></h2><p><a href="http://c.biancheng.net/matplotlib/9284.html" target="_blank" rel="noreferrer">http://c.biancheng.net/matplotlib/9284.html</a></p><h3 id="重写配置文件" tabindex="-1">重写配置文件 <a class="header-anchor" href="#重写配置文件" aria-label="Permalink to &quot;重写配置文件&quot;">​</a></h3><p>通过临时重写配置文件的方法，可以解决 Matplotlib 显示中文乱码的问题，代码如下所示：</p><div class="language-matlab vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">matlab</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> matplotlib.pyplot as plt</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">plt.rcParams[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;font.sans-serif&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]=[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SimHei&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] #设置字体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">plt.rcParams[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;axes.unicode_minus&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]=False #该语句解决图像中的“-”负号的乱码问题</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="数据归一化" tabindex="-1">数据归一化 <a class="header-anchor" href="#数据归一化" aria-label="Permalink to &quot;数据归一化&quot;">​</a></h2><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sklearn.preprocessing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MinMaxScaler</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 数据归一化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scaler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MinMaxScaler() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 实例化模型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X_train_normalized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scaler.fit_transform(x_train) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 训练缩放</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X_test_normalized </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scaler.transform(x_test) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 测试数据缩放</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="meshgrid" tabindex="-1">meshgrid <a class="header-anchor" href="#meshgrid" aria-label="Permalink to &quot;meshgrid&quot;">​</a></h2><p>假设有一个一维数组 <code>x</code> 和一个一维数组 <code>y</code>，它们分别是：</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numpy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们可以使用 <code>meshgrid</code> 生成网格点坐标矩阵：</p><p>(x为横向，y为竖向，以确保每个都有对应组合成不同值，x与y结合成格子)</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X, Y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.meshgrid(x, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Y)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>输出结果为：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[1 2 3]</span></span>
<span class="line"><span> [1 2 3]]</span></span>
<span class="line"><span>[[4 4 4]</span></span>
<span class="line"><span> [5 5 5]]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以看到，<code>X</code> 的第一行和第二行都是原始数组 <code>x</code> 的复制，而 <code>Y</code> 的第一列和第二列都是原始数组 <code>y</code> 的复制。</p><p><img src="`+l+`" alt="image-20230419111932753" loading="lazy"></p><h2 id="重塑数组结构" tabindex="-1">重塑数组结构 <a class="header-anchor" href="#重塑数组结构" aria-label="Permalink to &quot;重塑数组结构&quot;">​</a></h2><p><code>reshape(-1, 1)</code> 是 NumPy 中用于改变数组形状的方法之一，它的作用是将一个一维数组转化为二维数组，其中第一个维度是 -1，意思是让 NumPy 自动计算该维度的大小，第二个维度为 1，表示每个元素只有一个特征。</p><p>举个例子，假设有一个一维数组 a，它包含 6 个元素，我们可以使用 <code>reshape(-1, 1)</code> 将其转化为一个 6 行 1 列的二维数组 b：</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numpy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a.reshape(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 输出：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># [[1]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  [2]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  [3]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  [4]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  [5]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  [6]]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这个方法也可以用于将一个多维数组转化为一维数组，例如 <code>a.reshape(-1)</code> 将一个二维数组展平成一维数组。</p><h2 id="损失函数选择" tabindex="-1">损失函数选择 <a class="header-anchor" href="#损失函数选择" aria-label="Permalink to &quot;损失函数选择&quot;">​</a></h2><p><code>nn.CrossEntropyLoss()</code> 是一个用于计算交叉熵损失的函数，通常用于多分类问题中。</p><p><code>nn.MSELoss()</code> 是一个用于计算均方误差损失的函数。它可以用于回归问题中，衡量模型的预测值与真实值之间的差距。</p><h3 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h3><h4 id="自动编码解码器" tabindex="-1">自动编码解码器 <a class="header-anchor" href="#自动编码解码器" aria-label="Permalink to &quot;自动编码解码器&quot;">​</a></h4><p>自动编码解码器使用 MSELoss 均方误差损失函数。</p><p>MSE 损失函数假设输入和重构之间的关系是线性的。</p><p>在自动编码器中，我们希望解码器的输出尽可能接近原始输入，因此我们需要定义一个度量来衡量重构的质量。均方误差损失函数是衡量重构误差的一种常见选择。</p><p>MSE损失函数计算输入和目标之间的平均平方差，它对于大多数常见的连续数值问题是合适的。对于自动编码器而言，它可以帮助我们最小化输入和重构之间的平方差，从而促使解码器学习到有效的低维表示。</p><h4 id="卷积神经网络" tabindex="-1">卷积神经网络 <a class="header-anchor" href="#卷积神经网络" aria-label="Permalink to &quot;卷积神经网络&quot;">​</a></h4><p>使用 CrossEntropyLoss 函数，通常用来解决多分类问题。</p><p>交叉熵损失函数（CrossEntropyLoss）是用于解决分类问题的一种常见损失函数。它通常与softmax激活函数一起使用，用于衡量模型输出的概率分布与真实标签之间的差异。</p><p>交叉熵损失函数的定义基于信息论中的概念，它衡量两个概率分布之间的相似性。在分类问题中，我们希望模型的输出概率分布能够接近真实标签的分布。</p><h2 id="优化器" tabindex="-1">优化器 <a class="header-anchor" href="#优化器" aria-label="Permalink to &quot;优化器&quot;">​</a></h2><p><code>torch.optim.SGD</code> 是一种基础的随机梯度下降算法，它对每个参数都使用相同的学习率进行优化。在训练过程中，SGD 算法可以通过学习率调整、动量等技巧进行改进，但其对于参数更新的速度和方向控制较为简单，容易陷入局部最优解。</p><p><code>torch.optim.Adam</code> 是一种基于自适应学习率的优化算法，能够自适应地调整每个参数的学习率，从而更好地适应不同的梯度情况。相比于 SGD 算法，Adam 算法通常能够更快地收敛，在处理大规模数据和复杂模型时，也往往能够取得更好的效果。</p><p>因此，在选择使用 <code>torch.optim.SGD</code> 还是 <code>torch.optim.Adam</code> 时，可以参考以下几点建议：</p><ol><li>数据规模和模型复杂度：当数据规模较大或模型较为复杂时，可以考虑使用 Adam 算法，因为它能够自适应地调整每个参数的学习率，并能够更好地适应不同的梯度情况。</li><li>训练速度和效果：当训练速度和效果都比较重要时，可以根据实验结果选择合适的优化算法。通常情况下，SGD 算法的速度相对较快，但容易陷入局部最优解，而 Adam 算法的效果较好，但相对较慢。</li><li>调整学习率的需求：SGD 算法需要手动调整学习率，而 Adam 算法通常不需要手动调整学习率，可以根据实验需要选择是否需要手动调整学习率。</li></ol><p>综上所述，当数据规模较大、模型较为复杂或需要较好的训练效果时，可以考虑使用<code>torch.optim.Adam</code> 算法；而当数据规模较小、模型较简单或需要较快的训练速度时，可以考虑使用 <code>torch.optim.SGD</code> 算法。在实际使用时，也可以尝试使用不同的优化算法进行比较，根据实验结果选择最合适的算法。</p><h2 id="卷积层参数" tabindex="-1">卷积层参数 <a class="header-anchor" href="#卷积层参数" aria-label="Permalink to &quot;卷积层参数&quot;">​</a></h2><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CNN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CNN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.conv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nn.Conv2d(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">padding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.conv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nn.Conv2d(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">padding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.fc1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nn.Linear(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.fc2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nn.Linear(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.relu </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nn.ReLU()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.pool </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nn.MaxPool2d(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> forward</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, x):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.pool(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.relu(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.conv1(x)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.pool(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.relu(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.conv2(x)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x.view(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.relu(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.fc1(x))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.fc2(x)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>self.fc1 = nn.Linear(64 * 8 * 8, 128)中的参数是 64 * 8 * 8</strong>（依次是通道，宽和高）</p><p>在给定的代码中，<code>self.fc1 = nn.Linear(64 * 8 * 8, 128)</code>中的参数<code>(64 * 8 * 8)</code>表示前一层的输出特征图的大小。</p><p>在这个例子中，经过两个卷积层和池化层后，特征图的尺寸被减小到原始输入的1/4，即8 * 8。而在第二个卷积层之后，有64个特征图。</p><p>因此，<code>64 * 8 * 8</code>表示在第二个卷积层之后，展平的特征图的总大小为<code>64 * 8 * 8</code>。这个值作为输入传递给全连接层(<code>nn.Linear</code>)，并且输出维度被设置为128。</p><p>总而言之，<code>self.fc1 = nn.Linear(64 * 8 * 8, 128)</code>中的参数<code>(64 * 8 * 8)</code>是根据模型结构和输入数据的大小推导出来的，以确保正确的连接和尺寸匹配。</p><p><strong>64 * 8 * 8这三个数字各代表什么</strong></p><p>在这个上下文中，64 * 8 * 8 中的三个数字代表以下内容：</p><ol><li>64：表示第二个卷积层的输出通道数。在该模型中，第一个卷积层输出的特征图通道数为32，而第二个卷积层输出的特征图通道数为64。</li><li>8：表示经过卷积和池化操作后，特征图的空间尺寸（宽度和高度）被缩减为8。在给定的代码中，通过使用大小为3的卷积核（padding=1）和大小为2的最大池化层（stride=2），每个池化层将特征图的空间尺寸减小一半。</li><li>8：表示经过卷积和池化操作后，特征图的空间尺寸（宽度和高度）被缩减为8。在这个模型中，经过两个池化层，每个池化层将特征图的空间尺寸减小一半，所以初始的输入特征图的尺寸应为 8 * 8。</li></ol><p>综上所述，64 * 8 * 8 表示第二个卷积层后展平的特征图的总大小，其中64是特征图的通道数，8 * 8 是特征图的空间尺寸。这个值被用作第一个全连接层的输入尺寸。</p><h3 id="池化层" tabindex="-1">池化层 <a class="header-anchor" href="#池化层" aria-label="Permalink to &quot;池化层&quot;">​</a></h3><p><code>self.pool = nn.MaxPool2d(2, 2)</code> 将输入的特征图进行2倍下采样，通过将每个2x2的窗口内的最大值保留下来，而丢弃其他值。这样可以减小特征图的空间尺寸，同时保留重要的特征信息。在给定的代码中，该最大池化层被应用于两个卷积层之后，用于进一步减小特征图的尺寸。</p><h2 id="预测" tabindex="-1">预测 <a class="header-anchor" href="#预测" aria-label="Permalink to &quot;预测&quot;">​</a></h2><p>在机器学习中，predict和predict_proba都是用于预测模型输出的函数，但它们的作用略有不同。</p><p>predict函数主要用于分类任务，它接收输入数据并返回一个预测的类别，例如二元分类任务中的0或1，或多元分类任务中的类别编号。predict函数基于模型输出的类别概率进行决策，通常使用的是softmax函数。</p><p>predict_proba函数也用于分类任务，但与predict不同的是，它返回的是每个类别的概率估计值，而不是一个类别标签。这些概率值可以用于评估模型的不确定性，并帮助我们更好地理解模型的输出。predict_proba函数通常在二元或多元分类任务中使用，它们也可以使用softmax函数来计算类别概率。</p><p>需要注意的是，predict_proba函数的输出结果是一个概率向量，其中每个元素对应一个类别的概率值，这些概率值的总和为1。在一些应用场景中，我们可能只关心某个类别是否发生，而不是它的概率值，这时候可以使用predict函数，将概率估计值转化为类别标签。</p><h2 id="生成数据" tabindex="-1">生成数据 <a class="header-anchor" href="#生成数据" aria-label="Permalink to &quot;生成数据&quot;">​</a></h2><h3 id="数据之间划分" tabindex="-1">数据之间划分 <a class="header-anchor" href="#数据之间划分" aria-label="Permalink to &quot;数据之间划分&quot;">​</a></h3><p>np.linspace(0, 10, 100)</p><p>0 - 10 之间划分为100份</p><h3 id="按指定步长划分" tabindex="-1">按指定步长划分 <a class="header-anchor" href="#按指定步长划分" aria-label="Permalink to &quot;按指定步长划分&quot;">​</a></h3><p>np.arange(0,2*np.pi,0.1)</p><h2 id="定义模型" tabindex="-1">定义模型 <a class="header-anchor" href="#定义模型" aria-label="Permalink to &quot;定义模型&quot;">​</a></h2><p>在最后一层的全连接层中不使用激活函数是常见的做法。</p><p>在分类问题中，通常将最后一层的全连接层输出作为模型的原始预测值，然后再应用 softmax 函数或其他概率分布函数来生成最终的类别预测。这样的做法可以保持输出的线性范围，方便进行概率计算。</p><p>因此，在这种情况下，<code>self.fc2</code> 层的输出直接作为模型的原始预测值，而没有应用额外的激活函数。</p>`,101)]))}const y=i(h,[["render",e]]);export{c as __pageData,y as default};
