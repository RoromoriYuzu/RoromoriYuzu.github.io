import{_ as s,c as a,o as p,ag as i}from"./chunks/framework.BgId8OS5.js";const o="/post-images/1713877029273.jpg",t="/post-images/1713877835645.webp",l="/post-images/1713878207402.jpg",n="/post-images/1713878657852.jpg",r="/post-images/1713879053410.jpg",c="/post-images/1713880674248.jpg",d="/post-images/1713881107481.png",g="/post-images/1713881315978.jpg",h="/post-images/1713881479013.jpg",m="/post-images/1713881639316.jpg",k="/post-images/1713881824210.jpg",_="/post-images/1713882013568.jpg",u="/post-images/1713882606837.jpg",y="/post-images/1713939845162.jpg",b="/post-images/1713883640615.jpg",E="/post-images/1713886315190.jpg",j="/post-images/1713886381686.jpg",w=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/ReverseEngineering/学X通 PC客户端 JSCX 文件解密.md","filePath":"posts/ReverseEngineering/学X通 PC客户端 JSCX 文件解密.md","lastUpdated":null}'),x={name:"posts/ReverseEngineering/学X通 PC客户端 JSCX 文件解密.md"};function C(v,e,P,F,A,f){return p(),a("div",null,e[0]||(e[0]=[i('<blockquote><p>最近需要逆向学X通一些参数的加密过程，但相应功能只在客户端上才有，所以分析网页 JS 行不通。APP用了梆梆企业版加固，在网上找了一圈没找到什么脱壳教程遂放弃。PC端浓浓的 Electron 味，有戏！</p></blockquote><h2 id="electron-味哪里来" tabindex="-1">Electron 味哪里来？ <a class="header-anchor" href="#electron-味哪里来" aria-label="Permalink to &quot;Electron 味哪里来？&quot;">​</a></h2><p>学X通PC客户端是使用 electron + nodejs 框架，用 javascript 开发的跨平台的桌面程序。</p><h3 id="目录结构" tabindex="-1">目录结构 <a class="header-anchor" href="#目录结构" aria-label="Permalink to &quot;目录结构&quot;">​</a></h3><p>通常使用Electron构建的程序目录都类似以下这样</p><p><img src="'+o+'" alt="" loading="lazy"></p><p>最显眼的就是 locales 和 resources，两个文件夹，其中 locales 里面是放的应用程序的本地化（或国际化）资源。resources 里面是程序的相应的主体代码。</p><h3 id="页面风格" tabindex="-1">页面风格 <a class="header-anchor" href="#页面风格" aria-label="Permalink to &quot;页面风格&quot;">​</a></h3><p>常见的软件比如：Visual Studio Code，Postman，新版网易云音乐，QQNT，你可以在 <a href="https://www.electronjs.org/" target="_blank" rel="noreferrer">Electron</a> 官网底部看到更多。</p><p><img src="'+t+'" alt="" loading="lazy"></p><p>就连我现在使用的这个 Gridea 都是😂</p><h2 id="分析程序结构" tabindex="-1">分析程序结构 <a class="header-anchor" href="#分析程序结构" aria-label="Permalink to &quot;分析程序结构&quot;">​</a></h2><p>通常程序的主代码都在 resources 文件夹下，打包为 app.asar 。需要打包/解压工具 (npm i -g asar)</p><p>但是学X通并没有打包，也就省去了解包的步骤。</p><p><img src="'+l+'" alt="" loading="lazy"></p><p>需要解密的文件是位于 <code>cxstudyinhouse\\1.1.8.6\\resources\\app\\electron\\renderer</code> 目录下的 MainWindowHelper.jscx，打开是一大串无规则的字符串。</p><p><img src="'+n+'" alt="" loading="lazy"></p><p>经过查找解密步骤的实现在 <code>cxstudyinhouse\\1.1.8.6\\resources\\app\\module\\compile</code> 文件夹下。其中 lib 文件夹内 CompileUtil.js 作用是用于导出模块中的 getDbKey 函数，与解密 jscx 文件关系不大。</p><p>主要解密步骤在 Jscx.js 文件中</p><p><img src="'+r+'" alt="" loading="lazy"></p><h2 id="chatgpt-如是说道" tabindex="-1">ChatGPT 如是说道： <a class="header-anchor" href="#chatgpt-如是说道" aria-label="Permalink to &quot;ChatGPT 如是说道：&quot;">​</a></h2><p>这段代码的主要功能是为 Electron 应用程序添加对一个新的文件扩展名 <code>.jscx</code> 的支持。这个新的文件扩展名看起来像是一种预编译的 JavaScript 文件，可能包含一些特殊的优化或安全措施。</p><p>下面是这段代码的详细解析：</p><ol><li><p>首先，它导入了一些 Node.js 的内置模块，比如 <code>fs</code>（文件系统）、<code>v8</code>（V8 JavaScript 引擎）、<code>path</code>（路径处理）和 <code>Module</code>（模块系统）。</p></li><li><p>然后，根据当前的平台（<code>process.platform</code>），它导入了不同的 <code>CompileExt</code> 模块。如果当前平台是 macOS（<code>&quot;darwin&quot;</code>），则导入 <code>../mac/CompileExt</code>；否则，导入 <code>../win/CompileExt</code>。这个 <code>CompileExt</code> 模块可能包含了一些平台特定的编译或解析 <code>.jscx</code> 文件的代码。</p></li><li><p>接下来，它设置了 V8 JavaScript 引擎的一些标志，这里是 <code>--no-lazy</code>，这可能是为了优化 JavaScript 的编译。</p></li><li><p>最后，它为 Node.js 的模块系统添加了一个新的文件扩展名处理器。这个处理器定义了当 Node.js 遇到一个 <code>.jscx</code> 文件时应该如何处理。在这个处理器中，它创建了一个新的 <code>require</code> 函数，设置了一些属性，然后调用了 <code>compileExt.RunFile</code> 函数来处理 <code>.jscx</code> 文件。</p></li></ol><p>总的来说，这段代码的主要目的是为 Electron 应用程序添加对 <code>.jscx</code> 文件的支持，这可能是为了实现一些特殊的优化或安全措施。</p><hr><p>总的逻辑就是将 jscx 文件丢给 <code>../win/CompileExt</code> 解析运行。</p><p>CompileExt.node 是node.js Addon：通过 C++ 编写的扩展模块，用于扩展 Node.js 的功能。 还需要知道有：N-API（Node-API）是一组稳定的 C 语言 API，用于编写跨平台的 Node.js Addon。N-API 提供了一套抽象层，使得开发者可以更轻松地编写可移植的扩展模块，而无需担心不同版本的 Node.js 或不同平台之间的兼容性问题。</p><p>通过对几个 jscx 文件的观察，内容很像是 Base64 编码过的，但是使用Base64解码又不成功，那么大概率是 AES 或 DES 加密。</p><p>既然 CompileExt.node 可以解析 jscx 文件，那么应该是将加密过的 jscx 文件在内部用 key 解密转回 js 文件后再执行。</p><h2 id="ida-启动" tabindex="-1">IDA 启动！ <a class="header-anchor" href="#ida-启动" aria-label="Permalink to &quot;IDA 启动！&quot;">​</a></h2><p>CompileExt.node 既然是C++编译来的那就反编译查看他的解密逻辑。</p><p>通过搜索字符串 <code>crypto</code> 定位到相关代码段，F5 反编译为C代码</p><p><img src="'+c+'" alt="" loading="lazy"></p><p>大胆假设这段就是解密方法！</p><p>可以看到相关的解密代码，是调用了 <code>crypto.createDecipheriv</code> 函数，加密方法也和前面的猜想一样是使用了 <code>aes-128-ecb</code>，第二个参数是key也就是解密所需的密钥，第三个参数iv是空，可以忽略掉。</p><p>重点转移到 key 的值是如何来的</p><p><img src="'+d+'" alt="" loading="lazy"></p><p>查看Node.js的文档</p><p><img src="'+g+'" alt="" loading="lazy"></p><p>大胆假设一下，既然需要将 key 传递到 js 代码中那就需要创建一个相应的 js 的 key 字符串，那么v20 很可能就是 key ，又 <code>v20 = &amp;a10; </code> 而 a10 又是作为参数传递进来的</p><p><img src="'+h+'" alt="" loading="lazy"></p><p>那么就要看是谁调用了这个函数，给这个函数改个名，点击IDA菜单 <code>View-&gt;Open subviews-&gt;Function calls</code></p><p><img src="'+m+'" alt="" loading="lazy"></p><p>可以看到这个函数被调用了三次，先点进第一个看看，可以看到在61行调用了解密函数，a10对应的参数也就是我另起名的key</p><p><img src="'+k+'" alt="" loading="lazy"></p><p>在第59行可以看到将key的地址传递给了getKey函数（这是我后修改的名），继续跟进</p><p><img src="'+_+'" alt="" loading="lazy"></p><p>Assignment 函数的逻辑是将第二个参数以第三个参数的长度赋值给第一个参数</p><p>举个例子：在第62行的逻辑就是从v4+2，即v33+ 2，开始往后v3即3个字符，赋值给Block。</p><p>以下的几行差不多都是类似的逻辑</p><p><img src="'+u+'" alt="" loading="lazy"></p><p>但是他最后是将 *v23 什么的值赋值给 this ，但是我并不知道 *v23的值是怎么来的，他前面也没有过赋值😓</p><p>不过知道了key是在什么地方生成的，那么只需要相应地方打下断点，动态调试一下就知道具体的值了！</p><p>经过之后的测试发现，第一个调用是将前面那一大长串用 getKey 生成的 key 进行解密。</p><p>第二次和第三次调用都是在同一个函数内，区别为第二次才是真的将 jscx 文件解密 ，而第三次同样是将前面的一串字符解密运行。</p><p><img src="'+y+'" alt="" loading="lazy"></p><p>解密 jscx 文件要在以下地址下断点</p><p>52AD37A9 | E8 E2F7FFFF | call compileext.52AD2F90 | 调用解密函数</p><h2 id="xdbg-启动" tabindex="-1">xdbg 启动！ <a class="header-anchor" href="#xdbg-启动" aria-label="Permalink to &quot;xdbg 启动！&quot;">​</a></h2><p>打开 xdbg，运行学X通客户端，随便点几下确保 CompileExt.node 相关代码已经运行，接着搜索字符串 <code>HmoBjviHurIH+fe.....</code> ，定位到对应的代码行，对比一下</p><p><img src="'+b+'" alt="" loading="lazy"></p><p>call compileext.7B6A2F90 即为 call jiemi</p><p>在对应位置下断点，运行程序，当程序运行到断点处时查看堆栈区即有对应的 key 值。</p><p><img src="'+E+'" alt="" loading="lazy"></p><p>拿去尝试解密，确定就是密钥没错了。</p><p><img src="'+j+`" alt="" loading="lazy"></p><h2 id="后记" tabindex="-1">后记 <a class="header-anchor" href="#后记" aria-label="Permalink to &quot;后记&quot;">​</a></h2><p>最初我是想通过开启 Devtools 调试出key的，但是折腾一阵发现</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mainWindow.webContents.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openDevTools</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>找不到他具体的mainWindow是什么，new BrowserWindow 这条代码也是打包在 exe 中的，其他js文件中都没有。<a href="https://github.com/pd4d10/debugtron" target="_blank" rel="noreferrer">debugtron</a> 这个工具连学X通都识别不到。</p><p>另一个思路是在 js 层 hook api，修改他 crypto 库的文件，console.log(key)，但是 crypto 库也打包进了 exe 里，也只能放弃。</p><p>花了两天，简单的学了下 IDA 和 xdbg 通过动态调试可算把key找到了。从头到尾花了四天，还不错😇</p><hr><p>再更.....</p><p>发现有部分文件在断点处没有 key 的值，解决方法是将 main.jscx 解密后插入对应的代码，再用同一个key加密回去。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> robotTranslate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./test/robotTranslate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e) { console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e); }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>确保文件会被加载就可以看到对应key的值了。</p>`,78)]))}const z=s(x,[["render",C]]);export{w as __pageData,z as default};
